[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18385417&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

# Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

The process of designing, developing, and maintaining
          software


Identify and describe at least three key milestones in the evolution of software engineering.
 (i) Creation of Structured Programming

The shift from unstructured, spaghetti code to structured programming principles introduced modularity, making software easier to develop, debug, and maintain.

(ii)Introduction of Object-Oriented Programming 

The rise of object-oriented programming (OOP) brought reusable, scalable, and maintainable software development. Languages like C++, Java, and Python adopted OOP principles such as encapsulation, inheritance, and polymorphism.

(iii) Agile Methodology and DevOps

Agile development replaced rigid Waterfall models with iterative and flexible methodologies, improving responsiveness to change. DevOps emerged, integrating development and operations to enhance collaboration, automation, and continuous delivery.

List and briefly explain the phases of the Software Development Life Cycle.
(i)Requirement Analysis – Gathering and analyzing user needs.
(ii)Planning – Defining scope, timelines, and resources.
(iii)Design – Creating system architecture and UI/UX.
(iv)Implementation (Coding) – Writing and compiling source code.
(v)Testing – Identifying and fixing bugs through different testing levels.
(vi)Deployment – Releasing the software to users.
(vii)Maintenance – Ongoing updates, bug fixes, and improvements.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
(i)Waterfall has linear anad sequential approach while Agile has iterative and incremental approach
(ii)In Waterfall testing is done after development is done while agile it's continous testing throughout development.
(iii)In Waterfall customer involvement is limited while in Agile frequent collaboration and feedback is need

when to use:
Waterfall: Ideal for projects with well-defined requirements, such as enterprise software.
Agile: Best suited for projects with evolving requirements, such as SaaS applications.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

(i)Software Developer
Writes, tests, and maintains code.
Collaborates with designers and analysts to implement features.
Debugs and optimizes application performance.

(ii)Quality Assurance (QA) Engineer
Develops and executes test plans to ensure software reliability.
Identifies bugs and works with developers to resolve them.
Ensures adherence to software quality standards.

(iii)Project Manager
Plans and coordinates project timelines and resources.
Ensures communication between teams and stakeholders.
Manages risks, scope, and deliverables.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

(i)Integrated Development Environments (IDEs)

Provide features like syntax highlighting, debugging, and auto-completion.
Examples: Visual Studio Code, IntelliJ IDEA, PyCharm.

(ii)Version Control Systems (VCS)

Track code changes, enable collaboration, and maintain history.
Examples: Git, Subversion (SVN).

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

(i)Managing Technical Debt
Strategy: Refactor code regularly, follow best practices, and document properly.

(ii)Keeping Up with Rapid Technology Changes
Strategy: Continuous learning through courses, blogs, and hands-on projects.

(iii)Handling Debugging and Complex Bugs
Strategy: Use systematic debugging, logging tools, and peer code reviews.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

(i)Unit Testing
Tests individual functions or components.
Ensures each module works independently.

(ii)Integration Testing
Tests interactions between modules.
Verifies that combined components function correctly.

(iii)System Testing
Tests the complete system as a whole.
Ensures the application meets all requirements.

(iv)Acceptance Testing
Conducted by end-users to validate functionality.
Determines whether the software is ready for release.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Practice of designing and refining prompts to effectively interact with AI models and obtain accurate, relevant, and high-quality responses.

(i)Enhances AI Response Quality – Clear prompts ensure precise and useful answers.
(ii)Reduces Misinterpretation – Avoids vague or misleading outputs.
(iii)Improves Efficiency – Saves time by minimizing the need for multiple refinements.
(iv)Optimizes AI Capabilities – Helps leverage AI for complex tasks like data analysis, coding, or creative writing.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague Prompt:
"Tell me about technology."

Improved Prompt:
"Explain how artificial intelligence is transforming the healthcare industry, including examples of real-world applications."

Why Is the Improved Prompt More Effective?
(i)More Specific – Instead of a broad topic, it focuses on AI in healthcare.
(ii)Clear Intent – The AI understands exactly what to address.
(iii)Concise Yet Detailed – It provides direction without unnecessary complexity.
(iv)Encourages Informative Responses – Leads to a structured answer with relevant examples.